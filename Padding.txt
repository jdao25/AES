// char * right_pad_str(char * str, unsigned int pad_len)
// {
//     const unsigned int str_len = std::strlen(str);
//     unsigned int padded_str_len = str_len;
//
//     if (padded_str_len % pad_len != 0)
//         padded_str_len = (padded_str_len / pad_len + 1) * pad_len;
//
//     unsigned char *padded_str = malloc(padded_str_len);
//
//     for (int i = 0; i < padded_str_len; i++)
//     {
//         if (i >= str_len) padded_str[i] = 0;
//         else padded_str[i] = str[i];
//     }
//
//     return padded_str;
// }


// unsigned char* PKCS5Padding(char *strParams, int unBlockSize)
// {
//     int nRaw_size = std::strlen(strParams);
//     int i = 0, j = nRaw_size / 8 + 1, k = nRaw_size % 8;
//     int nPidding_size = 8 - k;
//     unsigned char* szArray;
//
//     szArray = (unsigned char *) malloc(nRaw_size + nPidding_size);
//     memcpy(szArray, strParams, nRaw_size);
//
//     for (int i1 = nRaw_size; i1 < (nRaw_size + nPidding_size); i1++)
//     {
//     	szArray[i1] = nPidding_size;
//     }
//
//     return szArray;
// }


void padding(unsigned char *message, int msgSize)
{
    // How much we need to pad the msg
    int padSize = (BLOCK_SIZE - msgSize) % BLOCK_SIZE;

    if (padSize == 0)
        padSize = BLOCK_SIZE;

    unsigned char value = (unsigned char)padSize;

    int start = msgSize;
    for (int idx = 0; idx < padSize; idx++)
        message[start++] = value;
}
