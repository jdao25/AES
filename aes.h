#ifndef AES_H
#define AES_H

// Headers
#include <iostream>
#include <fstream>
#include <cstring>
#include <string.h>
#include <map>

#ifdef _WIN32
#include <string>   // This is for the getline function to read key for Windows
#endif // ! _WIN32

#include "constants.h"


// Functions Declarations
void gFunction(unsigned char *, unsigned char); // Will be used in key scheduling process
void keyScheduling(unsigned char *, unsigned char *); // Expand key to 176 bytes. 16 bytes per round. 11 rounds
void keyAddition(unsigned char *, unsigned char *); // XOR Round key with state
void byteSubstitution(unsigned char *); // replace bytes with value in sbox
void shiftRows(unsigned char *); // Shift rows
void  mixColumns(unsigned char *); // Matrix multiplication  column with given matrix
char *encryption(unsigned char *, unsigned char *); // Encrypt the message using the key


void gFunction(unsigned char *input, unsigned char rcon_iter)
{
    // Rotate the word
    // The input should be the last word of the key
    unsigned char byteZero = input[0];

    for (int idx = 0; idx < 3; idx++)
        input[idx] = input[idx + 1];
    input[3] = byteZero;

    // Replace using the substitution box
    for (int idx = 0; idx < 4; idx++)
        input[idx] = sbox[input[idx]];

    // XOR
    input[0] ^= rcon[rcon_iter];
}


void keyScheduling(unsigned char *inputKey, unsigned char *key)
{
    /*
        This function takes in two arguments:
            1) original key user entered: inputKey
            2) key that will hold all rounds keys: key
    */

    // This is the number of bytes we have already generated. Set to 16 bytes
    unsigned int numBytes = BLOCK_SIZE;

    // Copying the first 16 bytes of the original key to the new key
    for (int idx = 0; idx < numBytes; idx++)
        key[idx] = inputKey[idx];

    // A temporary array to store the word for g function
    unsigned char temp[4];

    // Used to track the rcon idx position
    unsigned int rconIter = 1;

    // Keep looping until a total of 176 bytes had been generated
    while(numBytes < 176)
    {
        // Read the last 4 bytes (last column) of the already generated bytes
        for (int idx = 0; idx < 4; idx++)
             temp[idx] = key[idx + numBytes - 4];

        // Execute after each new key
        if (numBytes % BLOCK_SIZE == 0)
            gFunction(temp, rconIter++);

        // XOR the temp array from g function to with the first 4 bytes
        for (unsigned char idx = 0; idx < 4; idx++)
        {
            key[numBytes] = key[numBytes - BLOCK_SIZE] ^ temp[idx];
            numBytes++;
        }
    }
}


void keyAddition(unsigned char *state, unsigned char *roundKey)
{
    // XOR the state with the round key
    for (int idx = 0; idx < BLOCK_SIZE; idx++)
        state[idx] ^= roundKey[idx];
}


void byteSubstitution(unsigned char *state)
{
    // Substituting each box with what equivalent in the sbox
    for (int idx = 0; idx < BLOCK_SIZE; idx++)
        state[idx] = sbox[state[idx]];
}


void shiftRows(unsigned char *state)
{
    std::map<int, int> row = { {12, 1}, {13, 2}, {14, 3} };
    unsigned char tmp[BLOCK_SIZE];
    int idx = 0;    // Loop index
    int s1 = 0, s2 = 4, s3 = 8, s4 = 12;   // state index

    // Loop 4 times. One time per column
    for (idx = 0; idx < 4; idx++)
    {
        // Shifting each row in each column
        tmp[idx + 0] = state[s1];
        tmp[idx + 4] = state[s2];
        tmp[idx + 8] = state[s3];
        tmp[idx + 12] = state[s4];

        // Increment the state index
        s1 = ((s1 >= 12)? row[s1] : (s1 + 5) );
        s2 = ((s2 >= 12)? row[s2] : (s2 + 5) );
        s3 = ((s3 >= 12)? row[s3] : (s3 + 5) );
        s4 = ((s4 >= 12)? row[s4] : (s4 + 5) );
    }

    for (idx = 0; idx < BLOCK_SIZE; idx++)
        state[idx] = tmp[idx];
}


void  mixColumns(unsigned char *state)
{
    unsigned char tmp[BLOCK_SIZE];
    int idx = 0;

    for (idx = 0; idx < 4; idx++)
    {
        tmp[(idx << 2) + 0] =
            (unsigned char) (mul2[state[(idx << 2) + 0]] ^ mul_3[state[(idx << 2) + 1]]
            ^ state[(idx << 2) + 2] ^ state[(idx << 2) + 3]);
        tmp[(idx << 2) + 1] =
            (unsigned char) (state[(idx << 2) + 0] ^ mul2[state[(idx << 2) + 1]]
            ^ mul_3[state[(idx << 2) + 2]] ^ state[(idx << 2) + 3]);
        tmp[(idx << 2) + 2] =
            (unsigned char) (state[(idx << 2) + 0] ^ state[(idx << 2) + 1]
            ^ mul2[state[(idx << 2) + 2]] ^ mul_3[state[(idx << 2) + 3]]);
        tmp[(idx << 2) + 3] =
            (unsigned char) (mul_3[state[(idx << 2) + 0]] ^ state[(idx << 2) + 1]
            ^ state[(idx << 2) + 2] ^ mul2[state[(idx << 2) + 3]]);
    }

    for (idx = 0; idx < BLOCK_SIZE; idx++)
        state[idx] = tmp[idx];
}


char *encryption(unsigned char *message, unsigned char *key)
{
    // This will contain all the round keys from round 1 - 10 + initial
    unsigned char roundKeys[176];
    keyScheduling(key, roundKeys);

    unsigned char state[BLOCK_SIZE];

    for (int idx = 0; idx < BLOCK_SIZE; idx++)
        state[idx] = message[idx];

    keyAddition(state, roundKeys);

    const unsigned int rounds = 9;

    //  For rounds 1 - 9
    for (int round = 1; round <= 9; round++)
    {
        byteSubstitution(state);
        shiftRows(state);
        mixColumns(state);
        keyAddition(state, roundKeys + (BLOCK_SIZE * round));   // from the roundKeys skip to index (BLOCK_SIZE * round)
    }

    // Round 10
    byteSubstitution(state);
    shiftRows(state);
    keyAddition(state, roundKeys + 160);    // The word starting at roundKeys[160] is the last round key

    char * encryptedMessage  = (char *) malloc(16);
    memcpy(encryptedMessage, state, 16);

    return encryptedMessage;
}


#endif // ! AES_H
